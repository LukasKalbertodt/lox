use std::{
    // collections::HashSet,
    // fmt,
    io,
};


pub mod write;

use fev_core::{MeshElement};
use crate::{
    ser::{PrimitiveType, TypedLabel},
};

// use byteorder::{WriteBytesExt, BigEndian, LittleEndian};

// use crate::{
//     TriMesh, Pos3Like, Vec3Like,
//     handle::{DefaultIndex, FaceHandle, VertexHandle},
//     map::{FaceMap, VertexMap},
//     io::{
//         IntoMeshWriter, PropSetSerialize, MeshWriter, PropSerialize, PropSerializer,
//         PrimitiveType, PropLabel, PropSetSerializer, PropType, LabeledPropSet,
//         NameLabel, PropLabeler, StandardLabel,
//     },
// };



#[derive(Clone, Copy, Debug, PartialEq, Eq)]
pub enum PlyFormat {
    Ascii,
    BinaryBigEndian,
    BinaryLittleEndian,
}


#[derive(Clone, Copy, Debug)]
pub struct Ply {
    format: PlyFormat,
}

impl Ply {
    pub fn ascii() -> Self {
        Self::new(PlyFormat::Ascii)
    }

    pub fn binary() -> Self {
        Self::new(PlyFormat::BinaryBigEndian)
    }

    pub fn new(format: PlyFormat) -> Self {
        Self { format }
    }
}

// /// This is helper macro to quickly generate an `PropertySet` instance.
// ///
// /// The code generated by this macro already checks the PLY format and
// /// stores a function specialized for this format. This means that the format
// /// dispatch is only done once per property set and not everytime a property
// /// is serialized. But it also means that a lot of code is generated. I really
// /// need to check if this is worth it.
// macro_rules! pack_prop_set {
//     ($format:expr, $labels:expr, |$handle:ident| $val:expr) => {{
//         macro_rules! prop_set_with {
//             ($serializer:ident) => {
//                 PropertySet {
//                     labels: $labels,
//                     serialize: Box::new(move |w, is_first, $handle| {
//                         $val.serialize($serializer::new(w, is_first))
//                     }),
//                 }
//             }
//         }

//         match $format {
//             PlyFormat::Ascii => prop_set_with!(PlyAsciiPropSetSerializer),
//             PlyFormat::BinaryBigEndian => prop_set_with!(PlyBinaryBePropSetSerializer),
//             PlyFormat::BinaryLittleEndian => prop_set_with!(PlyBinaryLePropSetSerializer),
//         }
//     }}
// }


// impl<'a, MeshT> IntoMeshWriter<'a, MeshT> for Ply
// where
//     MeshT: TriMesh + 'a,
//     MeshT::VertexProp: LabeledPropSet + PropSetSerialize,
// {
//     type Error = PlyError;
//     type Writer = PlyWriter<'a, MeshT>;

//     fn serialize(self, mesh: &'a MeshT) -> Result<Self::Writer, Self::Error> {
//         // Populate our property lists with the properties stored inside the
//         // mesh (that is: properties of face and vertex + the property
//         // listing all vertices of a face).
//         // TODO: We can probably use the `.add` methods here to avoid dupe code,
//         //       but first, `Fn` need to implement `PropMap`
//         let vertex_prop_set = pack_prop_set!(
//             self.format,
//             MeshT::VertexProp::labels(),
//             |handle| mesh.vertex_prop(handle).unwrap() // TODO
//         );

//         let vertex_indices = {
//             // Prepare stuff to move into the `PropertySet`
//             let labeler = NameLabel("vertex_indices");

//             pack_prop_set!(
//                 self.format,
//                 PropLabeler::<[DefaultIndex; 3]>::labels(&labeler),
//                 |handle| labeler.wrap(mesh.vertices_of_face(handle))
//             )
//         };

//         Ok(PlyWriter {
//             format: self.format,
//             mesh,
//             vertex_prop_sets: vec![vertex_prop_set],
//             face_prop_sets: vec![vertex_indices], // TODO
//             vertex_prop_names: HashSet::new(),
//             face_prop_names: HashSet::new(),
//         })
//     }
// }

// struct PropertySet<'a, HandleT> {
//     labels: Vec<PropLabel>,
//     serialize: Box<'a + Fn(&mut io::Write, bool, HandleT) -> Result<(), PlyError>>,
// }


#[derive(Debug, Fail)]
pub enum PlyError {
    // #[fail(display =
    //     "unsupported index type: attempt to use a {} byte integer as vertex index (PLY only \
    //      supports 1, 2 and 4 byte integers)",
    //      num_bytes,
    // )]
    // IndexTypeNotSupported {
    //     num_bytes: u8,
    // },

    #[fail(display = "type '{}' is not supported by PLY", _0)]
    PrimitiveTypeNotSupported(PrimitiveType),

    // #[fail(display =
    //     "attempt to serialize a list-like property with a fixed length of {} (maximum is 2^32)",
    //     _0,
    // )]
    // FixedLenListTooLong(u64),

    #[fail(display =
        "attempt to add {} property `{:?}` to PLY file which uses the field name '{}', but a \
         property with that name has already been added ({:?})",
        element,
        new_label,
        name,
        old_label,
    )]
    NameAlreadyInUse {
        name: String,
        element: MeshElement,
        old_label: TypedLabel,
        new_label: TypedLabel,
    },

    // TODO: remove this
    #[fail(display = "something :(")]
    Something,
}

// #[derive(Copy, Clone, Debug)]
// pub enum ElementKind {
//     Vertex,
//     Face,
// }

// impl fmt::Display for ElementKind {
//     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
//         match *self {
//             ElementKind::Vertex => "vertex",
//             ElementKind::Face => "face"
//         }.fmt(f)
//     }
// }

impl From<io::Error> for PlyError {
    fn from(_src: io::Error) -> Self {
        PlyError::Something
    }
}

// fn label_names(label: &PropLabel) -> Vec<&str> {
//     match label {
//         PropLabel::Position { .. } => vec!["x", "y", "z"],
//         PropLabel::Normal { .. } => vec!["nx", "ny", "nz"],
//         PropLabel::Named { name, .. } => vec![name.as_str()],
//     }
// }
